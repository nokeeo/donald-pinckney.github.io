<!DOCTYPE html>
<html lang="en-us">

  <head>
  <!-- <link href="https://gmpg.org/xfn/11" rel="profile"> -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/fonts/abril_pt.css">
  <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> -->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  <!-- MathJax -->
  <!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script> -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML'></script>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- jQuery -->
  <script src="/public/js/jquery.js"></script>

  <!-- TOC -->
  <script src="/public/js/toc.js"></script>



  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Metal 3D Graphics Part 1: Basic Rendering | Donald Pinckney</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Metal 3D Graphics Part 1: Basic Rendering" />
<meta name="author" content="Donald Pinckney" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What is Metal, and why use it? Metal is a powerful new GPU programming API designed by Apple. Originally it was announced in 2014 for iOS and claimed significant performance benefits over OpenGL, the standard 3D graphics API, and since 2014 it has gained the ability for general purpose GPU computation, cross-platform support between iOS and macOS, and other features. But what exactly is it, and how does it compare to OpenGL?" />
<meta property="og:description" content="What is Metal, and why use it? Metal is a powerful new GPU programming API designed by Apple. Originally it was announced in 2014 for iOS and claimed significant performance benefits over OpenGL, the standard 3D graphics API, and since 2014 it has gained the ability for general purpose GPU computation, cross-platform support between iOS and macOS, and other features. But what exactly is it, and how does it compare to OpenGL?" />
<link rel="canonical" href="https://donaldpinckney.com/metal/2018/06/28/metal-intro-1.html" />
<meta property="og:url" content="https://donaldpinckney.com/metal/2018/06/28/metal-intro-1.html" />
<meta property="og:site_name" content="Donald Pinckney" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-28T00:00:00-07:00" />
<script type="application/ld+json">
{"description":"What is Metal, and why use it? Metal is a powerful new GPU programming API designed by Apple. Originally it was announced in 2014 for iOS and claimed significant performance benefits over OpenGL, the standard 3D graphics API, and since 2014 it has gained the ability for general purpose GPU computation, cross-platform support between iOS and macOS, and other features. But what exactly is it, and how does it compare to OpenGL?","author":{"@type":"Person","name":"Donald Pinckney"},"@type":"BlogPosting","url":"https://donaldpinckney.com/metal/2018/06/28/metal-intro-1.html","headline":"Metal 3D Graphics Part 1: Basic Rendering","dateModified":"2018-06-28T00:00:00-07:00","datePublished":"2018-06-28T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://donaldpinckney.com/metal/2018/06/28/metal-intro-1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Donald Pinckney
        </a>
      </h1>
      <p class="lead">Tinkering with math, CS, and other random stuff.</p>
    </div>

    <nav class="sidebar-nav">
      <div class="horizontal-block">
        <div class="horizontal-item">
        </div>
        
        <a class="horizontal-item sidebar-nav-item" href="/">Home</a>
        

        
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
        
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/categories/">Categories</a>
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/ml.html">ML Resources</a>
            
          
        
          
        
          
        
          
        

        <a class="horizontal-item sidebar-nav-item" href="/books/tensorflow/book">TensorFlow Book</a>

        <div class="horizontal-item">
        </div>
      </div>

      <hr />

      <div class="horizontal-block">
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/about.html">About Me</a>
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        


        <a href="https://github.com/donald-pinckney" class="sidebar-nav-item horizontal-item" target="_blank">
          <i class="fa fa-github"></i><span class="only-desktop"> donald-pinckney</span>
        </a>
        <a href="https://twitter.com/donald_pinckney" class="sidebar-nav-item horizontal-item" target="_blank">
          <i class="fa fa-twitter"></i><span class="only-desktop">@donald_pinckney</span>
        </a>
      </div>
    </nav>

    <div class="sidebar-footnote">
      <p class="sidebar-footnote">
        &copy; 2018 Donald Pinckney. All rights reserved.
        <!-- <br />
        The views and opinions expressed here are my own, and do not reflect the views of Apple, Inc. -->
      </p>
    </div>
  </div>
</div>


    <div class="content container">
      <div class="post">

  
    <h1 class="post-title titular floating-box-left">Metal 3D Graphics Part 1: Basic Rendering</h1>
  
  
  
    <div class="edit-me floating-box-right">
      
        <a href="https://github.com/donald-pinckney/donald-pinckney.github.io/blob/src/_posts/metal/metal-intro-1.md" target="_blank">
      
      <i class="fa fa-pencil"></i>Edit this page</a>

    </div> 
  

  <span class="post-date">28 Jun 2018. Categories: 
  <!-- <div class="post-categories"> -->
  
  
  <a href="/categories/#Metal">Metal</a>
  
  
<!-- </div> -->

</span>



<div id="toc"></div>
<script type="text/javascript">
  $(document).ready(function() {
    // alert("READY");
      $('#toc').toc();
  });
</script>


<h1 id="what-is-metal-and-why-use-it">What is Metal, and why use it?</h1>
<p><a href="https://developer.apple.com/metal/">Metal</a> is a powerful new GPU programming API designed by Apple. Originally it was announced in 2014 for iOS and claimed significant performance benefits over <a href="https://www.opengl.org">OpenGL</a>, the standard 3D graphics API, and since 2014 it has gained the ability for general purpose GPU computation, cross-platform support between iOS and macOS, and other features. But what exactly is it, and how does it compare to OpenGL?</p>

<p>Both Metal and OpenGL are low-level APIs that provide programmable access to GPU hardware for 3D graphics. Both allow you to write code that will execute on the GPU to customize how 3D objects are rendered. However, OpenGL tends to hide the communication between the CPU and the GPU, whereas Metal requires you to explicitly program this communication.</p>

<p>This gives us two advantages: first, it allows for greater efficiency in terms of CPU and GPU communication; and second it provides an excellent learning opportunity to understand how this low-level communication works. But don’t let this scare you: while this might sound horribly complicated, but actually it’s quite elegant and enjoyable code to write.</p>

<p>Finally, a quick note about what this tutorial is and what it isn’t: it is meant to give a brief introduction to the very basics of rendering with Metal, with little or no prior knowledge required about Swift or 3D graphics. Later tutorials will build on this by looking at programming interesting 3D effects in Metal. However, if your goal is to get started quickly with game development, learning Metal is probably not the fastest way to make a game; instead you should look at higher-level game engines, such as <a href="https://unity3d.com">Unity</a> or others.</p>

<p>Rendering a 2D multi-colored triangle is the hello world program for graphics, and is the goal for this post. We will develop specifically for macOS since it is most convenient, but the code will actually be cross-platform with iOS and tvOS. To visualize the end goal, a screenshot of it looks like this:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/screen1.png" alt="End Goal Screenshot" /></p>

<h1 id="rough-sketch-of-graphics-pipelines">Rough Sketch of Graphics Pipelines</h1>
<p>3D graphics are generally described by geometry, which is usually specified by the <strong>vertices</strong> of triangles. These vertices are generated by code on the CPU, and then need to be sent over to the GPU for rendering. The vertex data will then be fed through a GPU pipeline, eventually resulting in a final image being rendered, which can then be displayed on screen:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/basic_pipeline.png" alt="Basic GPU Pipeline" /></p>

<p>In short, a <strong>pipeline</strong> is a series of pre-configured steps that the GPU hardware takes to turn a bunch of vertex data into a final rendered image. Modern 3D graphics requires being able to program exactly what happens inside of the pipeline, and describing the pipeline via code is the central concept in Metal programming. Programming a simple pipeline that can render a single 2D triangle is the goal of this tutorial, and as we go through the code we will break this abstract pipeline into detailed individual components.</p>

<h1 id="basic-setup-and-clearing-the-screen">Basic Setup and Clearing the Screen!</h1>

<h2 id="creating-a-one-window-macos-app">Creating a one window macOS app</h2>
<p>Open Xcode (make sure to install the latest version of Xcode from the Mac App Store), make a new Xcode project, choose “Cocoa App” under “macOS”, and hit next. Then, fill in whatever you want for the Product Name (I’ll use <code class="highlighter-rouge">MetalIntro1</code>), choose Swift for the language, make sure Use Storyboards is checked, and Create Document-Based Application is <em>not</em> checked. My settings look like this:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/xcode1.png" alt="Project Settings" /></p>

<p>Then, hit Next, and save it somewhere. If you run the app (⌘R) then a single blank window should appear. This blank window is where we want to display our 3D graphics. Before we can write actual Metal code, we need a way for the 3D graphics to even appear in our window.</p>

<h2 id="setting-up-a-metalkit-view">Setting Up a MetalKit View</h2>
<p>Everything visual in <code class="highlighter-rouge">macOS</code> is represented by a <em>view</em>, which concretely is a subclass of <code class="highlighter-rouge">NSView</code>. We need a view in our window in which we can display the results of the Metal graphics rendering. Apple provides a prebuilt view just for this purpose, <code class="highlighter-rouge">MTKView</code>, which we will take advantage of.</p>

<p>First, we need to add a <code class="highlighter-rouge">MTKView</code> to the window by modifying the Storyboard file, and then we need to configure it via code. Open <code class="highlighter-rouge">Main.storyboard</code>, select the root view of the view controller, and in the inspector panel change the class from <code class="highlighter-rouge">NSView</code> to <code class="highlighter-rouge">MTKView</code>, as shown below.</p>

<p><img src="/public/post_assets/metal/metal-intro-1/xcode2.png" alt="Modifying the Storyboard" /></p>

<p>Now to configure the <code class="highlighter-rouge">MTKView</code> we need to write some initialization code in the view controller, so open <code class="highlighter-rouge">ViewController.swift</code>. We will need access to the Metal framework, and the auxiliary MetalKit framework, so add these imports at the top:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Metal</span>
<span class="kd">import</span> <span class="kt">MetalKit</span>
</code></pre></div></div>

<p>First we want to save the <code class="highlighter-rouge">MTKView</code> in a convenient variable, so add the following instance variable to the view controller class:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">mtkView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="o">!</span>
</code></pre></div></div>

<p>To initialize this variable in the <code class="highlighter-rouge">viewDidLoad</code> function add this code to the <code class="highlighter-rouge">viewDidLoad</code> function, after the <code class="highlighter-rouge">super.viewDidLoad()</code> call:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">mtkViewTemp</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">view</span> <span class="k">as?</span> <span class="kt">MTKView</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"View attached to ViewController is not an MTKView!"</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="n">mtkView</span> <span class="o">=</span> <span class="n">mtkViewTemp</span>
</code></pre></div></div>

<p>Now we can configure <code class="highlighter-rouge">mtkView</code>. The two necessary properties to configure are the <code class="highlighter-rouge">device</code> and the <code class="highlighter-rouge">delegate</code>. The device is easiest, so we will do it first. The <code class="highlighter-rouge">device</code> (of type <code class="highlighter-rouge">MTLDevice</code>) represents the actual GPU hardware. We can retrieve the default GPU and save it to the <code class="highlighter-rouge">mtkView</code> like so:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">defaultDevice</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Metal is not supported on this device"</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"My GPU is: </span><span class="se">\(</span><span class="n">defaultDevice</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="n">mtkView</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">defaultDevice</span>
</code></pre></div></div>

<p>If you run the app now, it should print in the Xcode console what your GPU is, but nothing will be rendered inside the window, since we haven’t told Metal to do any rendering. To set this up we need to configure the <code class="highlighter-rouge">delegate</code> property of the <code class="highlighter-rouge">mtkView</code>. The <code class="highlighter-rouge">delegate</code>is an independent object which is responsible for performing our custom rendering, whenever the <code class="highlighter-rouge">mtkView</code> asks it to. The great thing about this approach is that it is easy to write platform independent code: our view controller code is specific to macOS, but it is very short; the meat of the code will live inside the object we assign to the <code class="highlighter-rouge">delegate</code>property.</p>

<p>So we need to make a new <code class="highlighter-rouge">class</code> who’s responsibility is to render our custom graphics whenever <code class="highlighter-rouge">mtkView</code> asks it to. To do so it just needs to implement the <code class="highlighter-rouge">MTKViewDelegate</code> protocol. Let’s make a new Swift file called <code class="highlighter-rouge">Renderer.swift</code>, and add the code below to declare a new <code class="highlighter-rouge">Renderer</code> class (and import the needed frameworks):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Metal</span>
<span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">class</span> <span class="kt">Renderer</span> <span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">MTKViewDelegate</span> <span class="p">{</span>

    <span class="c1">// This is the initializer for the Renderer class.</span>
    <span class="c1">// We will need access to the mtkView later, so we add it as a parameter here.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">mtkView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="c1">// mtkView will automatically call this function</span>
    <span class="c1">// whenever it wants new content to be rendered.</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="k">in</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="p">}</span>

    <span class="c1">// mtkView will automatically call this function</span>
    <span class="c1">// whenever the size of the view changes (such as resizing the window).</span>
    <span class="kd">func</span> <span class="nf">mtkView</span><span class="p">(</span><span class="n">_</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">,</span> <span class="n">drawableSizeWillChange</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This class includes an initializer (with an <code class="highlighter-rouge">MTKView</code> as a parameter), and the two required functions for implementing the <code class="highlighter-rouge">MTKViewDelegate</code> protocol. We will come back to filling in the <code class="highlighter-rouge">draw(in view: MTKView)</code> function later, but first we will finish writing all of the code for <code class="highlighter-rouge">ViewController.swift</code>.</p>

<p>Now that we have this skeleton class, we can create an instance in the <code class="highlighter-rouge">viewDidLoad</code> function and configure <code class="highlighter-rouge">mtkView</code> with it. First, we add an instance variable for it to the <code class="highlighter-rouge">ViewController</code> class:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="o">!</span>
</code></pre></div></div>

<p>At the end of the <code class="highlighter-rouge">viewDidLoad</code> function we create an instance of the <code class="highlighter-rouge">Renderer</code> class, and configure the <code class="highlighter-rouge">delegate</code> property:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">tempRenderer</span> <span class="o">=</span> <span class="kt">Renderer</span><span class="p">(</span><span class="nv">mtkView</span><span class="p">:</span> <span class="n">mtkView</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Renderer failed to initialize"</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="n">renderer</span> <span class="o">=</span> <span class="n">tempRenderer</span>
        
<span class="n">mtkView</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">renderer</span>
</code></pre></div></div>

<p>At this point we are completely done with the setup code, and now we can move on to actual Metal code. For reference, here is my final version of <code class="highlighter-rouge">ViewController.swift</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Cocoa</span>
<span class="kd">import</span> <span class="kt">Metal</span>
<span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">NSViewController</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">mtkView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="o">!</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>

        <span class="c1">// First we save the MTKView to a convenient instance variable</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">mtkViewTemp</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">view</span> <span class="k">as?</span> <span class="kt">MTKView</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"View attached to ViewController is not an MTKView!"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">mtkView</span> <span class="o">=</span> <span class="n">mtkViewTemp</span>
        
        <span class="c1">// Then we create the default device, and configure mtkView with it</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">defaultDevice</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Metal is not supported on this device"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="s">"My GPU is: </span><span class="se">\(</span><span class="n">defaultDevice</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="n">mtkView</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">defaultDevice</span>
        
        <span class="c1">// Lastly we create an instance of our Renderer object, </span>
        <span class="c1">// and set it as the delegate of mtkView</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">tempRenderer</span> <span class="o">=</span> <span class="kt">Renderer</span><span class="p">(</span><span class="nv">mtkView</span><span class="p">:</span> <span class="n">mtkView</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Renderer failed to initialize"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">renderer</span> <span class="o">=</span> <span class="n">tempRenderer</span>
                
        <span class="n">mtkView</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">renderer</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="clearing-the-screen-by-issuing-gpu-commands">Clearing the Screen by Issuing GPU Commands</h2>

<p>We have everything setup for us to start writing graphics code in <code class="highlighter-rouge">Renderer.swift</code>. Before we draw a triangle, we will start with clearing the screen, which will involve issuing commands to GPU, and transferring the results back to the <code class="highlighter-rouge">mtkView</code>.</p>

<p>Metal requires us to keep track of a queue (essentially a list) of commands that are waiting to be executed on the GPU. A Metal command queue is represented by the class <code class="highlighter-rouge">MTLCommandQueue</code>, and commands are represented by the class <code class="highlighter-rouge">MTLCommandBuffer</code>. This is an outline of what we need to do to have a full render pass working:</p>

<ol>
  <li>At initialization time, create one <code class="highlighter-rouge">MTLCommandQueue</code> (call it <code class="highlighter-rouge">commandQueue</code>).</li>
  <li>At each draw cycle, create a <code class="highlighter-rouge">MTLCommandBuffer</code>, configure it to include the draw commands we want, and then add it to <code class="highlighter-rouge">commandQueue</code></li>
  <li>Once the <code class="highlighter-rouge">MTLCommandBuffer</code> finishes executing on the GPU, we need to display the results in the <code class="highlighter-rouge">mtkView</code>.</li>
</ol>

<p>Let’s start with the first task. We need to keep track of one <code class="highlighter-rouge">MTLCommandQueue</code> for the whole <code class="highlighter-rouge">Renderer</code> class. For convenience we also want to keep track of the <code class="highlighter-rouge">MTLDevice</code>, since we will use it a lot later. So, add the following instance variables to the <code class="highlighter-rouge">Renderer</code> class:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span>
<span class="k">let</span> <span class="nv">commandQueue</span><span class="p">:</span> <span class="kt">MTLCommandQueue</span>
</code></pre></div></div>

<p>Now, inside the initializer (the <code class="highlighter-rouge">init?</code> function) add the following code to setup these variables:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">device</span> <span class="o">=</span> <span class="n">mtkView</span><span class="o">.</span><span class="n">device</span><span class="o">!</span>

<span class="n">commandQueue</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeCommandQueue</span><span class="p">()</span><span class="o">!</span>
</code></pre></div></div>

<p>Note that we have to use the <code class="highlighter-rouge">device</code> to create a new command queue: this means that a command queue is associated with a specific device, and can only be used with that device.</p>

<p>We have now initialized a command queue, so now in the <code class="highlighter-rouge">draw(in view: MTKView)</code> we can create a <code class="highlighter-rouge">MTLCommandBuffer</code>, configure it, and add it to the queue. In the <code class="highlighter-rouge">draw(in view: MTKView)</code> function the first thing we do is create a new <code class="highlighter-rouge">MTLCommandBuffer</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get an available command buffer</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">makeCommandBuffer</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</code></pre></div></div>

<p>Now, we need to configure <code class="highlighter-rouge">commandBuffer</code> to perform drawing commands that we want. First, we use a <code class="highlighter-rouge">MTLRenderPassDescriptor</code> to configure some options about input and output. <em>When that is finalized</em>, we then use a <code class="highlighter-rouge">MTLRenderCommandEncoder</code> to configure what drawing operations the GPU will perform.</p>

<p>There are a lot of options to configure for the <code class="highlighter-rouge">MTLRenderPassDescriptor</code>. Fortunately, the <code class="highlighter-rouge">MTKView</code> provides us with a pre-configured <code class="highlighter-rouge">MTLRenderPassDescriptor</code>, so we can just grab that and then change the default options:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get the default MTLRenderPassDescriptor from the MTKView argument</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">renderPassDescriptor</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">currentRenderPassDescriptor</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

<span class="c1">// Change default settings. For example, we change the clear color from black to red.</span>
<span class="n">renderPassDescriptor</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="kt">MTLClearColorMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>More configure options on a <code class="highlighter-rouge">MTLRenderPassDescriptor</code> will be discussed in future posts, but for now the most important option is the <code class="highlighter-rouge">colorAttachments</code> array. The first (and for now only) item in the <code class="highlighter-rouge">colorAttachments</code> array describes the output destination of the rendering. In this case, setting the <code class="highlighter-rouge">clearColor</code> property to <code class="highlighter-rouge">(1, 0, 0, 1)</code> (these are RGBA values) tells Metal to clear the color attachment to a value of <code class="highlighter-rouge">(1, 0, 0, 1)</code> before rendering. Other notable properties that the <code class="highlighter-rouge">MTKView</code> set for us include <code class="highlighter-rouge">renderTargetWidth</code> and <code class="highlighter-rouge">renderTargetHeight</code>, which were automatically set to the size of the <code class="highlighter-rouge">MTKView</code>.</p>

<p>This is all that we need to do to configure <code class="highlighter-rouge">renderPassDescriptor</code>. We now finalize it by converting it into a <code class="highlighter-rouge">MTLRenderCommandEncoder</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We compile renderPassDescriptor to a MTLRenderCommandEncoder.</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">renderEncoder</span> <span class="o">=</span> <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">makeRenderCommandEncoder</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">renderPassDescriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>  
</code></pre></div></div>

<p>At this point we would use <code class="highlighter-rouge">renderEncoder</code> to encode various drawing commands to tell the GPU to draw triangles based on vertex data. For now we just want to clear the screen, so we don’t need to encode any drawing commands.</p>

<p>Since we are done encoding our drawing commands (none of them), we finish the encoding process:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This finalizes the encoding of drawing commands.</span>
<span class="n">renderEncoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span>
</code></pre></div></div>

<p>At this point, <code class="highlighter-rouge">commandBuffer</code> as been configured via <code class="highlighter-rouge">renderPassDescriptor</code> and <code class="highlighter-rouge">renderEncoder</code> to describe a bunch of GPU commands for an entire render pass. The <code class="highlighter-rouge">commandBuffer</code> includes rendering output information, such as output width and height, the clear color, and other properties, as well as a (currently empty) list of encoded drawing commands. However, <em>calling <code class="highlighter-rouge">endEncoding()</code> does NOT send this information to the GPU yet!</em> This gives us control about when to actually trigger expensive drawing commands on the GPU, vs. just finish encoding them.</p>

<p>We are now ready to send the encoded commands to the GPU. However, it is crucial to understand that the CPU and GPU work asynchronously: so when we send the encoded commands to the GPU, it will work on completing them while the CPU code continues to run, and then finish the commands and obtain the color image result at some indeterminate point in the future. But, we need a way to know when the rendering finishes and at that time place the result into the <code class="highlighter-rouge">MTKView</code>. If we don’t do this, the GPU will finish rendering, and then the result will simply disappear, since the CPU doesn’t even know about the result.</p>

<p>Setting up the callback to place it into the <code class="highlighter-rouge">MTKView</code> is very easy, since <code class="highlighter-rouge">MTKView</code> actually provides most of the implementation for us. We just need to tell the <code class="highlighter-rouge">commandBuffer</code> to present into the <code class="highlighter-rouge">MTKView</code>’s drawable:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tell Metal to send the rendering result to the MTKView when rendering completes</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="nf">present</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">currentDrawable</span><span class="p">)</span>
</code></pre></div></div>

<p>A drawable is simply a resource managed by the <code class="highlighter-rouge">MTKView</code> which Metal can write the result into.</p>

<p>Now, we are finally ready to send the encoded command buffer to the GPU. This is just one of line code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Finally, send the encoded command buffer to the GPU.</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>Note that <code class="highlighter-rouge">commandBuffer.commit()</code> is a bit more nuanced than just sending the command buffer to the GPU. Since <code class="highlighter-rouge">commandBuffer</code> is actually stored in <code class="highlighter-rouge">commandQueue</code>, writing <code class="highlighter-rouge">commandBuffer.commit()</code> will prepare it for execution on the GPU, at the back of the queue. So other command buffers that are ahead of it in line (that were committed first) will execute first.</p>
</blockquote>

<p>Running the code now should look like this:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/screen2.png" alt="Clear Red Screen" /></p>

<p>And for reference the current code in <code class="highlighter-rouge">Renderer.swift</code> is:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">Metal</span>
<span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">class</span> <span class="kt">Renderer</span> <span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">MTKViewDelegate</span> <span class="p">{</span>
    
    <span class="k">let</span> <span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span>
    <span class="k">let</span> <span class="nv">commandQueue</span><span class="p">:</span> <span class="kt">MTLCommandQueue</span>
    
    <span class="c1">// This is the initializer for the Renderer class.</span>
    <span class="c1">// We will need access to the mtkView later, so we add it as a parameter here.</span>
    <span class="nf">init</span><span class="p">?(</span><span class="nv">mtkView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">mtkView</span><span class="o">.</span><span class="n">device</span><span class="o">!</span>
        
        <span class="n">commandQueue</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeCommandQueue</span><span class="p">()</span><span class="o">!</span>
    <span class="p">}</span>
    
    <span class="c1">// mtkView will automatically call this function</span>
    <span class="c1">// whenever it wants new content to be rendered.</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="k">in</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Get an available command buffer</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">makeCommandBuffer</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        
        <span class="c1">// Get the default MTLRenderPassDescriptor from the MTKView argument</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">renderPassDescriptor</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">currentRenderPassDescriptor</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        
        <span class="c1">// Change default settings. For example, we change the clear color from black to red.</span>
        <span class="n">renderPassDescriptor</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="kt">MTLClearColorMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1">// We compile renderPassDescriptor to a MTLRenderCommandEncoder.</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">renderEncoder</span> <span class="o">=</span> <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">makeRenderCommandEncoder</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">renderPassDescriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        
        <span class="c1">// TODO: Here is where we need to encode drawing commands!</span>
        
        <span class="c1">// This finalizes the encoding of drawing commands.</span>
        <span class="n">renderEncoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span>
        
        <span class="c1">// Tell Metal to send the rendering result to the MTKView when rendering completes</span>
        <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">present</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">currentDrawable</span><span class="o">!</span><span class="p">)</span>
        
        <span class="c1">// Finally, send the encoded command buffer to the GPU.</span>
        <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// mtkView will automatically call this function</span>
    <span class="c1">// whenever the size of the view changes (such as resizing the window).</span>
    <span class="kd">func</span> <span class="nf">mtkView</span><span class="p">(</span><span class="n">_</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">,</span> <span class="n">drawableSizeWillChange</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="hello-triangle">Hello, Triangle!</h1>

<h2 id="a-review-of-the-metal-architecture">A Review of the Metal Architecture</h2>

<p>With the code to clear the screen, we have most of the infrastructure that we need for performing rendering passes. Not all, but most. Since there are a lot of different pieces to the Metal API, let’s briefly organize these into a mental picture. The GPU executes pipelines which transform vertex data and encoded drawing commands into a final image result. The different Metal classes fit in as so:</p>

<ul>
  <li>A <code class="highlighter-rouge">MTLCommandBuffer</code> represents the entire set of information the GPU needs to execute this pipeline: it contains the pipeline info itself, as well as vertex data and drawing commands that will be fed into the pipeline by the GPU.</li>
  <li>A <code class="highlighter-rouge">MTLRenderPassDescriptor</code> is used to configure the interface of the pipeline, but not the interior of the pipeline. It is like the 2 openings of the pipe.</li>
  <li>A <code class="highlighter-rouge">MTLRenderCommandEncoder</code> is used to prepare the vertex data and drawing commands that will be fed into the pipeline (we will see code for this in the next section).</li>
  <li>A <code class="highlighter-rouge">MTLCommandQueue</code> keeps track of many <code class="highlighter-rouge">MTLCommandBuffer</code>s that are waiting in line to be executed.</li>
  <li>A <code class="highlighter-rouge">MTLDevice</code> represents the actual GPU.</li>
</ul>

<p>Sketched as picture, the interactions of these pieces look like:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/clear_sketch.png" alt="Metal Sketch" /></p>

<h2 id="details-of-the-pipeline">Details of the Pipeline</h2>

<p>In the above diagram, we have written code to setup or configure pretty much all parts of it. The two pieces we have avoided so far are encoding drawing commands / vertex data, and configuring the pipeline itself. We have configured the <code class="highlighter-rouge">MTLRenderPassDescriptor</code>, which is the openings to the pipeline, how it connects to the rest, but we have not configured the internals of the pipeline.</p>

<p>Configuring the pipeline itself is really the whole point of graphics programming: this is the code which will render vertex data with any given effect we can code. And in Metal configuring a custom pipeline is <em>necessary</em> for being able to render vertices: otherwise the GPU has no way of knowing how to transform encoded drawing commands into a final image.</p>

<p>There are many parts to the interior of the pipeline, some of which we can write fully custom code for, and others are a fixed function provided by the GPU. Here is a diagram of the main parts of the pipeline:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/pipeline.png" alt="A sketch of a graphics pipeline" /></p>

<p>The stages marked in green are the ones that we can write fully custom code for, while the others are done mostly automatically by the GPU. Also, note that the first stage, the custom encoding of drawing commands is done on the CPU, and all other steps are done on the GPU.</p>

<ol>
  <li>Encoding Drawing Commands / Vertex Data: The data that the GPU receives, and that must be processed in the pipeline.</li>
  <li>Vertex Shader: Converts the 3D vertex locations into 2D screen coordinates. It also passes vertex data down the pipeline.</li>
  <li>Tessellation: Subdivides triangles into further triangles to provide higher-quality results.</li>
  <li>Rasterization: Discretizes the 2D geometric data into 2D discrete pixels. This will also take data attached to each vertex and interpolate it over the whole shape to every rasterized pixel.</li>
  <li>Fragment Shader: Given the interpolated pixel data from the rasterizer, the fragment shader determines the final color of each pixel.</li>
</ol>

<p>Tessellation is an advanced technique that will be looked at much later, but the drawing command encoding, vertex shader, and fragment shader are necessary parts for the pipeline, and we will work on setting them up now.</p>

<h2 id="creating-vertex-and-fragment-shaders">Creating Vertex and Fragment Shaders</h2>

<p>Vertex and fragment shaders are written in a special programming language, the <a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shading Language</a> (MSL). It is based on C++, with some extra features for describing properties of vertex and fragment shaders.</p>

<p>We want our MSL code (running on the GPU) to share some <code class="highlighter-rouge">struct</code> definitions with our Swift code (running on the CPU), since both sides need to know how vertex data will be communicated to the GPU. We will write a C <code class="highlighter-rouge">struct</code>, which can be used by the MSL code since it is based on C++, and by the Swift code, since Swift can import C type definitions. To do so we need to setup a bridging header, so Swift knows which C header files to import.</p>

<p>Probably the easiest (though pretty annoying) way to setup a bridging header is to create a new Objective-C <em>(NOT C)</em> file in Xcode (you can call it anything), and it should prompt you to create a bridging header. Click “Create Bridging Header”, and then you can immediately delete the Objective-C file you made.</p>

<p>We can now make a C header file which will be imported by both the MSL code and the Swift code. Create a new file, and choose “Header File”. Name it <code class="highlighter-rouge">ShaderDefinitions.h</code>, and create it. Then, in the bridging header add the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "ShaderDefinitions.h"
</span></code></pre></div></div>

<p>We are now ready to define a <code class="highlighter-rouge">struct</code> which will determine what data constitutes a vertex. Since our goal is to have a 2D colored triangle, we need at a minimum to describe the position and color of each vertex. The triangle is 2D, so the positions can be described with 2 dimensions, and the colors can be described with 4 dimensions (RGBA). In vertex <code class="highlighter-rouge">struct</code>s we will typically want the <code class="highlighter-rouge">struct</code> members to be vectors, in this case a vector of length 2 for the position, and a vector of length 4 for the color. To conveniently use vector types we use the <code class="highlighter-rouge">simd.h</code>library. In <code class="highlighter-rouge">ShaderDefinitions.h</code> add the following include and <code class="highlighter-rouge">struct</code> definition:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;simd/simd.h&gt;
</span>
<span class="k">struct</span> <span class="n">Vertex</span> <span class="p">{</span>
    <span class="n">vector_float4</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">vector_float2</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>We have the data structure for vertex data ready, so now we can make our shaders. Create a new file, and this time choose “Metal file”, and name it <code class="highlighter-rouge">Shaders.metal</code>. Now, the vertex shader is a function, which converts input vertex data into final locations of vertices on the screen. It is declared like any C / C++ function, but with a special keyword so Metal knows that it is a vertex shader. Similarly, a fragment shader is a function that converts interpolated data into a final pixel color, and also has a special keyword. Add the following to <code class="highlighter-rouge">Shaders.metal</code>:</p>

<pre><code class="language-metal">// TODO: We need to change the parameters and return types of the shaders.

vertex void vertexShader()
{

}

fragment void fragmentShader()
{

}
</code></pre>

<p>We will come back to fixing the types of the functions shortly, but first we will load the shaders and setup vertex data on the CPU.</p>

<h2 id="setting-up-a-pipeline">Setting up a Pipeline</h2>

<p>To use our shaders we need to configure our own custom pipeline in <code class="highlighter-rouge">Renderer.swift</code>. To do so we configure a <code class="highlighter-rouge">MTLRenderPipelineDescriptor</code>, and then compile it to a finalized <code class="highlighter-rouge">MTLRenderPipelineState</code>, all at initialization time.</p>

<p>We will do this in a new function. Add this new class function stub to <code class="highlighter-rouge">Renderer</code> (we will see why we need the parameters soon):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create our custom rendering pipeline, which loads shaders using `device`, and outputs to the format of `metalKitView`</span>
<span class="kd">class</span> <span class="kd">func</span> <span class="nf">buildRenderPipelineWith</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span><span class="p">,</span> <span class="nv">metalKitView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">MTLRenderPipelineState</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, inside this function we need to construct a <code class="highlighter-rouge">MTLRenderPipelineDescriptor</code>, and then configure it. We start by constructing one:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a new pipeline descriptor</span>
<span class="k">let</span> <span class="nv">pipelineDescriptor</span> <span class="o">=</span> <span class="kt">MTLRenderPipelineDescriptor</span><span class="p">()</span>
</code></pre></div></div>

<p>Now, there are only 3 properties we need to configure: the vertex shader, the fragment shader, and the format that pixel data is produced as. To load the shader code in <code class="highlighter-rouge">Shaders.metal</code>, we use the “default library”: a collection of all the compiled Metal shader files in the app. We can then access the vertex and fragment shader functions by name:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Setup the shaders in the pipeline</span>
<span class="k">let</span> <span class="nv">library</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeDefaultLibrary</span><span class="p">()</span>
<span class="n">pipelineDescriptor</span><span class="o">.</span><span class="n">vertexFunction</span> <span class="o">=</span> <span class="n">library</span><span class="p">?</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"vertexShader"</span><span class="p">)</span>
<span class="n">pipelineDescriptor</span><span class="o">.</span><span class="n">fragmentFunction</span> <span class="o">=</span> <span class="n">library</span><span class="p">?</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"fragmentShader"</span><span class="p">)</span>
</code></pre></div></div>

<p>The device is required to make the default library (and is thus a parameter for the function), since when this code is rune the Metal code must be compiled into final machine code that is specific to the device.</p>

<p>We also need to tell the pipeline in what format to store the pixel data. Options include how many bytes per pixel, and in what order to store red, green, blue, and alpha. But we just need the pipeline’s output format to match the format of the <code class="highlighter-rouge">MTKView</code>, which is why an <code class="highlighter-rouge">MTKView</code> is a parameter. We setup this configuration with one line:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Setup the output pixel format to match the pixel format of the metal kit view</span>
<span class="n">pipelineDescriptor</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">metalKitView</span><span class="o">.</span><span class="n">colorPixelFormat</span>
</code></pre></div></div>

<p>Lastly, we have to compile the pipeline descriptor to a final pipeline, ready to be executed on the GPU. We return the result, and in case of an error we throw the error:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compile the configured pipeline descriptor to a pipeline state object</span>
<span class="k">return</span> <span class="k">try</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeRenderPipelineState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">pipelineDescriptor</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we just need to use our <code class="highlighter-rouge">buildRenderPipelineWith(device: MTLDevice, metalKitView: MTKView)</code> function to save the pipeline into an instance variable. Add this instance variable to <code class="highlighter-rouge">Renderer</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">pipelineState</span><span class="p">:</span> <span class="kt">MTLRenderPipelineState</span>
</code></pre></div></div>

<p>And in the initializer add the following:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create the Render Pipeline</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">pipelineState</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Renderer</span><span class="o">.</span><span class="nf">buildRenderPipelineWith</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">device</span><span class="p">,</span> <span class="nv">metalKitView</span><span class="p">:</span> <span class="n">mtkView</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Unable to compile render pipeline state: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="sending-vertex-data-and-drawing-commands-to-the-gpu">Sending Vertex Data and Drawing Commands to the GPU</h2>

<p>Now that we have a configured pipeline, we had better use it. That means we need to send vertex data to the GPU, and drawing commands telling it what to do with that data. First, let’s discuss what exactly vertex data is, and then we will implement it. After that, encoding drawing commands is easy.</p>

<p>As described above, vertex data just stores information about each vertex. In the vertex data itself we do not specify what types of shapes (points, lines, or triangles) the vertices describe, that is done later in the draw call. The information stored in vertex data is entirely up to us: we can include any vector data in it, in any format that is convenient for us. We already decided this format above: a <code class="highlighter-rouge">vector_float4</code> for color (RGBA), and a <code class="highlighter-rouge">vector_float2</code> for XY screen coordinates. However, how should we scale the X coordinate? It could be a real screen coordinate, in the range of 0 to <code class="highlighter-rouge">width</code>, or it could be a normalized screen coordinate, in the range of -1 (left) to 1 (right). Likewise for the Y coordinate. Again, it is entirely up to us. As we will see, it is the job of the vertex shader to translate our arbitrary vertex data to consistent position data for the GPU to understand. For simplicity we will use normalized screen coordinates. First, we create an array of our desired vertex data in the initializer of <code class="highlighter-rouge">Renderer</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create our vertex data</span>
<span class="k">let</span> <span class="nv">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Vertex</span><span class="p">(</span><span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">pos</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
	        <span class="kt">Vertex</span><span class="p">(</span><span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">pos</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
	        <span class="kt">Vertex</span><span class="p">(</span><span class="nv">color</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">pos</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
</code></pre></div></div>

<p>If you are unsure how this vertex data relates to our final goal of drawing a triangle with red, green, and blue vertices, then I suggest getting our a piece of paper and sketching the positions of these vertices, and their colors.</p>

<p>This vertex data is correct, but it’s not accessible by the GPU, since it is stored in CPU accessible memory, not GPU accessible memory. To make it accessible by the GPU, we must use a <code class="highlighter-rouge">MTLBuffer</code>, which provides access to CPU and GPU shared memory. Add an instance variable to <code class="highlighter-rouge">Renderer</code> for this buffer:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">vertexBuffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span>
</code></pre></div></div>

<p>And in the initializer you can now create a buffer:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// And copy it to a Metal buffer...</span>
<span class="n">vertexBuffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeBuffer</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="n">vertices</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="n">vertices</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Vertex</span><span class="o">&gt;.</span><span class="n">stride</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span><span class="o">!</span>
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">makeBuffer</code> function takes <code class="highlighter-rouge">length</code> bytes stored at the given pointer in CPU memory, and copies the bytes directly into a newly allocated shared CPU / GPU buffer. In this case the buffer looks like this:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/buffer.png" alt="Buffer" /></p>

<p>Keep in mind that the GPU doesn’t automatically know anything about the structure, all it sees is the raw bytes in the bottom row of the above diagram.  The only way the GPU knows about the structure of the vertex data is because we will code our vertex shader accordingly (in a bit). As a side note, the padding bytes are added into the buffer for each vertex so that 16 bytes alignment is maintained. This has ups and downs, and can be avoided, which may be discussed in a future post.</p>

<p>At this point we have both the pipeline and the vertex data prepared. The last code we need to write on the CPU side is to encode drawing commands for the GPU. Let’s return to the function <code class="highlighter-rouge">draw(in view: MTKView)</code>, and look at the section between creating <code class="highlighter-rouge">renderEncoder</code> and calling <code class="highlighter-rouge">renderEncoder.endEncoding()</code>. Between these is where we want to place our code to encode drawing commands. First, we tell it what pipeline and what vertex data buffer to use:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Setup render commands to encode</span>
<span class="c1">// We tell it what render pipeline to use</span>
<span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">pipelineState</span><span class="p">)</span>
<span class="c1">// What vertex buffer data to use</span>
<span class="n">renderEncoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>We use <code class="highlighter-rouge">offset: 0</code> since we want Metal to read the buffer starting at the beginning. Metal supports sending multiple vertex buffers in one render pass; we only have one vertex buffer so it must be at index 0, so we use <code class="highlighter-rouge">index: 0</code>.</p>

<p>Lastly, we need to encode the actual drawing command to the GPU:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// And what to draw</span>
<span class="n">renderEncoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">triangle</span><span class="p">,</span> <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>We tell Metal to draw a triangle (other options include <code class="highlighter-rouge">point</code>, <code class="highlighter-rouge">line</code>, <code class="highlighter-rouge">lineStrip</code> and <code class="highlighter-rouge">triangleStrip</code>, possibly explored in later posts), and to start drawing using the vertex at position 0 in the buffer. Clearly we have 3 vertices to draw for our one triangle. At this point, the code in <code class="highlighter-rouge">Renderer.swift</code> is complete for this post!</p>

<h2 id="type-signatures-of-vertex-and-fragment-shaders">Type Signatures of Vertex and Fragment Shaders</h2>

<p>The only work we have left to do is in the vertex and fragment shaders: they are currently empty stubs! If we run the code right now, an error message like this is printed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-07-03 16:12:37.685893-0700 MetalIntro1[13387:661616] Compiler failed to build request
Unable to compile render pipeline state: Error Domain=CompilerError Code=1 "RasterizationEnabled is true but the vertex shader's return type is void" UserInfo={NSLocalizedDescription=RasterizationEnabled is true but the vertex shader's return type is void}
Renderer failed to initialize
</code></pre></div></div>

<p>This is just saying that the type signatures of the vertex and fragment shader functions are not correct. What should they be instead?</p>

<p>Well, we know that the job of the vertex shader is to pre-process per-vertex data, so its input must be some form of vertex data. In fact, the vertex shader will take the entire buffer (actually a pointer to it) and a vertex ID which indexes into this buffer as input. So when we perform our draw call with a buffer of 3 vertices, the vertex shader will be invoked once for each vertex for a total of 3 times, each time with the same buffer pointer as an argument, but with vertex indices of 0, 1, 2, respectively. Omitting the return type for now, in Metal shader code these 2 vertex shader function parameters look like:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vertex</span> <span class="o">???</span> <span class="n">vertexShader</span><span class="p">(</span><span class="k">const</span> <span class="n">device</span> <span class="n">Vertex</span> <span class="o">*</span><span class="n">vertexArray</span> <span class="p">[[</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]])</span>
</code></pre></div></div>

<p>Since we are using the <code class="highlighter-rouge">Vertex</code> struct here, don’t forget to add <code class="highlighter-rouge">#include "ShaderDefinitions.h"</code> to the top of the Metal shader file. Now, most of this seems clear enough: we have a constant pointer to our <code class="highlighter-rouge">MTLBuffer</code> containing <code class="highlighter-rouge">Vertex</code> structs, and an unsigned integer vertex ID. But there is some new syntax here to break down.</p>

<p>First, <code class="highlighter-rouge">device</code> indicates in what address space of the GPU should the <code class="highlighter-rouge">vertexArray</code> be placed in. The two options are <code class="highlighter-rouge">device</code> (read-write address space) and <code class="highlighter-rouge">constant</code> (read-only address space). However, semantically and for efficiency one should use <code class="highlighter-rouge">device</code> for data which will be accessed differently by each vertex (this is our case, we have a different vertex ID for each vertex) and use <code class="highlighter-rouge">constant</code> for data which all vertices will use in the same way. Note that we don’t have to specify the address space of <code class="highlighter-rouge">vid</code> since it is a simple type, not a pointer type.</p>

<p>Second, Metal uses the <code class="highlighter-rouge">[[...]]</code> syntax to specify Metal specific annotations. We said that we want one parameter to be the vertex buffer, which means that Metal has to call this function and pass the vertex buffer as the first argument. But Metal does not know by itself which parameter of the vertex shader function it should pass the vertex buffer to, so writing <code class="highlighter-rouge">[[buffer(0)]]</code> is how we tell Metal that this specific parameter <code class="highlighter-rouge">vertexArray</code> is where is should pass the first buffer. Note that the <code class="highlighter-rouge">0</code> here corresponds directly to the <code class="highlighter-rouge">index: 0</code> in the call <code class="highlighter-rouge">renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)</code>.</p>

<p>Similarly, Metal needs to pass the vertex ID to the vertex shader function, so writing <code class="highlighter-rouge">[[vertex_id]]</code> on the second parameter tells Metal where to pass the vertex ID.</p>

<p>Before we discuss the return type of the vertex shader, let’s decide the return type of the fragment shader, since it is easy. Recall that the fragment shader’s job is to receive interpolated data per-pixel from the rasterizer (which receives data from the vertex shader), and then output the final pixel color. At the point that Metal calls the fragment shader the GPU already knows the position of the pixel, just not the color. The only data the fragment shader needs to return is the color, and thus the return type can simply be <code class="highlighter-rouge">float4</code>. As a side note, in the Metal shader language, <code class="highlighter-rouge">float4</code> is just the same as <code class="highlighter-rouge">vector_float4</code> in the <code class="highlighter-rouge">simd.h</code> library.</p>

<p>As for the return type (call it <code class="highlighter-rouge">T</code>) of the vertex shader, the key realization is that the output of the vertex shader (<code class="highlighter-rouge">T</code>) is fed to the rasterizer, which will interpolate this output over the appropriate destination pixels, and then call the fragment shader with this interpolated data (interpolated version of <code class="highlighter-rouge">T</code>). So, the return type <code class="highlighter-rouge">T</code> of the vertex shader must match the parameter of the fragment shader, plus some Metal specific interpolation magic. As for what <code class="highlighter-rouge">T</code> is, it really can be arbitrary, <em>except that it must provide a screen-space position coordinate</em>. Remember, the vertex shader must convert the positions in the vertex buffer to normalized screen-space positions. For now this is easy, since our vertex buffer already contains normalized screen-space positions. But we will still need to tell Metal where this normalized screen-space position is, using a <code class="highlighter-rouge">[[...]]</code> annotation.</p>

<p>For rendering our triangle, our vertex shader just needs to pass the color of the vertex into the rasterizer for interpolation, and then into the fragment shader. So we declare a new <code class="highlighter-rouge">struct</code> type in <code class="highlighter-rouge">Shaders.metal</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexOut</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">pos</span> <span class="p">[[</span><span class="n">position</span><span class="p">]];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">float4 color</code> is just the color data we want to pass through. There are two interesting things though about <code class="highlighter-rouge">pos</code>. First, we use <code class="highlighter-rouge">[[position]]</code> to tell the Metal rasterizer to use this field of the struct as the normalized screen-space position for performing the rasterizing / interpolation. Second, although I keep saying that we must use a normalized <em>screen-space</em> (2D) coordinate for the position for rasterizing, <code class="highlighter-rouge">pos</code> is actually 4 dimensional, and in fact it must be. In spirit <code class="highlighter-rouge">pos</code> is 2 dimensional, but the 3rd coordinate can be used for depth: it doesn’t actually affect where the vertex is on screen, but can be used to track depth. The last coordinate is used to put <code class="highlighter-rouge">pos</code> into 4D homogeneous space: a standard, useful, and unfortunately confusing way to store locations in 3D graphics. Fortunately, both the 3rd and 4th components we do not have to worry about in this post, we just need to keep them there to make Metal happy.</p>

<p>We can now give final typed stubs of the vertex and fragment shader functions:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexOut</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">pos</span> <span class="p">[[</span><span class="n">position</span><span class="p">]];</span>
<span class="p">};</span>

<span class="n">vertex</span> <span class="n">VertexOut</span> <span class="nf">vertexShader</span><span class="p">(</span><span class="k">const</span> <span class="n">device</span> <span class="n">Vertex</span> <span class="o">*</span><span class="n">vertexArray</span> <span class="p">[[</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)]],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]])</span>
<span class="p">{</span>
    <span class="c1">// TODO: Write vertex shader
</span><span class="p">}</span>

<span class="n">fragment</span> <span class="n">float4</span> <span class="nf">fragmentShader</span><span class="p">(</span><span class="n">VertexOut</span> <span class="n">interpolated</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span>
<span class="p">{</span>
    <span class="c1">// TODO: Write fragment shader
</span><span class="p">}</span>
</code></pre></div></div>

<p>All the pieces of this have been explained, except for <code class="highlighter-rouge">[[stage_in]]</code>. This is another Metal attribute, which tells Metal that parameter <code class="highlighter-rouge">interpolated</code> should be fed the interpolated results of the rasterizer.</p>

<h2 id="writing-vertex-and-fragment-shader-code">Writing Vertex and Fragment Shader Code</h2>

<p>Finally, we get to write the actual implementations of the vertex and fragment shader, starting with the vertex shader.</p>

<p>The first task in the vertex shader is to fetch the vertex data of the given vertex ID:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get the data for the current vertex.
</span><span class="n">Vertex</span> <span class="n">in</span> <span class="o">=</span> <span class="n">vertexArray</span><span class="p">[</span><span class="n">vid</span><span class="p">];</span>
</code></pre></div></div>

<p>Now we need to create an instance of <code class="highlighter-rouge">VertexOut</code>, set its properties and return it. Starting with the color is easy:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VertexOut</span> <span class="n">out</span><span class="p">;</span>

<span class="c1">// Pass the vertex color directly to the rasterizer
</span><span class="n">out</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</code></pre></div></div>

<p>As for the position, we need to convert our vertex data of the form \((x_v, y_v)\) to the form \((x_s, y_s, z, w)\), where \(x_s\) and \(y_s\) must be in normalized screen-space. In our case \(x_v\) and \(y_v\) are already in normalized screen-space, so we assign them directly to \(x_s\) and \(y_s\). As for \(z\) (depth) and \(w\) (homogeneous component) it suffices to use values of 0 and 1. After that we simply return <code class="highlighter-rouge">out</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pass the already normalized screen-space coordinates to the rasterizer
</span><span class="n">out</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">return</span> <span class="n">out</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>Vertex shaders which simply pass data through mostly unchanged to the rasterizer are a very common pattern, and are called pass-through vertex shaders.</p>
</blockquote>

<p>Now, to code the fragment shader, all we need to do is return the final color we want. But the rasterizer has already linearly interpolated the colors of the 3 vertices among the rasterized pixels, which is exactly what we want. Thus, the only code in the fragment shader is:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">interpolated</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</code></pre></div></div>

<p>Now we can finally compile and run the code, and we see:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/screen3.png" alt="Red Screen With Multicolored Triangle" /></p>

<p>That is almost what we wanted! We just forgot that we left the clear color at red. Go back and change the clear color to black, and it should look like this:</p>

<p><img src="/public/post_assets/metal/metal-intro-1/screen4.png" alt="Black Screen With Multicolored Triangle" /></p>

<p>Congratulations, you have just learned most of the fundamentals behind Metal. Perhaps this was a bit long (it was a longer post than I expected), but it is pretty cool to synthesize all of the basic concepts together.</p>

<p>For reference the complete sample project is <a href="/public/post_assets/metal/metal-intro-1/MetalIntro1.zip">available for download here</a>.</p>

<h1 id="concluding-remarks">Concluding Remarks</h1>
<p>This post covered a lot of material; to recap, we saw how to:</p>
<ol>
  <li>Setup a MetalKit view in a native macOS app.</li>
  <li>Manage a <code class="highlighter-rouge">MTLCommandQueue</code> and <code class="highlighter-rouge">MTLCommandBuffer</code> objects to send commands to the GPU.</li>
  <li>Configure rendering properties using <code class="highlighter-rouge">MTLRenderPassDescriptor</code>.</li>
  <li>Setup a pipeline with custom shaders using <code class="highlighter-rouge">MTLRenderPipelineDescriptor</code>.</li>
  <li>Prepare our custom vertex data, and send it over to the GPU using <code class="highlighter-rouge">MTLBuffer</code>.</li>
  <li>Write basic pass-through shaders.</li>
</ol>

<p>These concepts are crucial: without them it’s impossible to do any Metal programming. But the good news is that these concepts are mostly the same regardless of what you are doing with Metal: we will add complexity on top of this solid foundation.</p>

<h1 id="exercises">Exercises</h1>

<p>What’s really great and fun about graphics programming is that it is easy to experiment with and try things on your own. Below are some suggestions for things to try; some are more structured than others, but they are roughly sorted in increasing order of difficulty. Do as many as you please!</p>

<ol>
  <li>Try moving around the positions of the vertices of the triangle, making sure you are comfortable with how normalized screen-space coordinates work.</li>
  <li>In graphics there are usually multiple ways to achieve the same effect, but with different tradeoffs. We don’t care about the tradeoffs yet, but we can experiment with different ways to do things. Make the triangle all blue <em>by only modifying <code class="highlighter-rouge">Renderer.swift</code></em>, so it looks like this: <img src="/public/post_assets/metal/metal-intro-1/screen5.png" alt="All Blue Triangle" />.</li>
  <li>Again make the triangle all blue, but this time *by only modifying <code class="highlighter-rouge">Shaders.metal</code>. After doing this, in what way could you simplify the <code class="highlighter-rouge">Vertex</code> data struct, buffer, and <code class="highlighter-rouge">VertexOut</code>?</li>
  <li>Flip the triangle upside down <em>by only modifying <code class="highlighter-rouge">Renderer.swift</code></em>, so it looks like this: <img src="/public/post_assets/metal/metal-intro-1/screen6.png" alt="Upside down triangle" />.</li>
  <li>Again flip the triangle upside down <em>but this time only modify <code class="highlighter-rouge">Shaders.metal</code></em>.</li>
  <li>Render a rectangle instead of a triangle.</li>
  <li>Try to render a circle <em>by modifying <code class="highlighter-rouge">Shaders.metal</code> only</em> (you can use rectagle code from 6. in <code class="highlighter-rouge">Renderer.swift</code> if you want). Hint: you can use <code class="highlighter-rouge">interpolated.pos</code> to also determine color, BUT it is in unnormalized screen-space! It is fine if you code is hacky and does not work as the window resizes.</li>
  <li>Try to render a circle by using the normal code (or single color code) for <code class="highlighter-rouge">Shaders.metal</code>, but by creating a ton of triangles in <code class="highlighter-rouge">Renderer.swift</code>.</li>
  <li>Play around and experiment with whatever you want!</li>
</ol>


</div>



<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/tensorflow/2018/02/25/multi-variable.html" class="titular">
            Multi Variable Linear Regression
            <small>25 Feb 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/tensorflow/2017/12/27/optimization.html" class="titular">
            Exploring Optimization Convergence
            <small>27 Dec 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/tensorflow/2017/12/03/single-variable.html" class="titular">
            Single Variable Linear Regression
            <small>03 Dec 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

  </body>
</html>
