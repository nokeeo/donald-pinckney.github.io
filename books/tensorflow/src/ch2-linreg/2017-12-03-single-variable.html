<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  <!-- MathJax -->
  <!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script> -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML'></script>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Single Variable Linear Regression | Donald Pinckney</title>
<meta property="og:title" content="Single Variable Linear Regression" />
<meta name="author" content="Donald Pinckney" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Who tinkers with math, CS, and random stuff." />
<meta property="og:description" content="Who tinkers with math, CS, and random stuff." />
<link rel="canonical" href="http://donaldpinckney.com/books/tensorflow/src/ch2-linreg/2017-12-03-single-variable.html" />
<meta property="og:url" content="http://donaldpinckney.com/books/tensorflow/src/ch2-linreg/2017-12-03-single-variable.html" />
<meta property="og:site_name" content="Donald Pinckney" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-03T00:00:00-08:00" />
<script type="application/ld+json">
{"name":null,"description":"Who tinkers with math, CS, and random stuff.","author":{"@type":"Person","name":"Donald Pinckney"},"@type":"BlogPosting","url":"http://donaldpinckney.com/books/tensorflow/src/ch2-linreg/2017-12-03-single-variable.html","publisher":null,"image":null,"headline":"Single Variable Linear Regression","dateModified":"2017-12-03T00:00:00-08:00","datePublished":"2017-12-03T00:00:00-08:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://donaldpinckney.com/books/tensorflow/src/ch2-linreg/2017-12-03-single-variable.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Donald Pinckney
        </a>
      </h1>
      <p class="lead">Who tinkers with math, CS, and random stuff.</p>
    </div>

    <nav class="sidebar-nav">
      <div class="horizontal-block">
        <div class="horizontal-item">
        </div>
        
        <a class="horizontal-item sidebar-nav-item" href="/">Home</a>
        

        
        
          
            
          
        
          
            
          
        
          
            
          
        
          
        
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/categories/">Categories</a>
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/ml.html">ML Resources</a>
            
          
        
          
        
          
        
          
        

        <a class="horizontal-item sidebar-nav-item" href="/books/tensorflow/book">TensorFlow Book</a>

        <div class="horizontal-item">
        </div>
      </div>

      <hr />

      <div class="horizontal-block">
        
          
        
          
        
          
        
          
            
              <a class="horizontal-item sidebar-nav-item" href="/about.html">About Me</a>
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        


        <a href="https://github.com/donald-pinckney" class="sidebar-nav-item horizontal-item" target="_blank">
          <i class="fa fa-github"></i><span class="only-desktop"> donald-pinckney</span>
        </a>
        <a href="https://twitter.com/donald_pinckney" class="sidebar-nav-item horizontal-item" target="_blank">
          <i class="fa fa-twitter"></i><span class="only-desktop">@donald_pinckney</span>
        </a>
      </div>
    </nav>

    <div class="sidebar-footnote">
      <p class="sidebar-footnote">
        &copy; 2017 Donald Pinckney. All rights reserved.
        <!-- <br />
        The views and opinions expressed here are my own, and do not reflect the views of Apple, Inc. -->
      </p>
    </div>
  </div>
</div>


    <div class="content container">
      <div class="post">

  
    <h1 class="post-title titular floating-box-left">Single Variable Linear Regression</h1>
  
  
  
    <div class="edit-me floating-box-right">
      
        <a href="https://github.com/donald-pinckney/donald-pinckney.github.io/blob/src/books/tensorflow/src/ch2-linreg/2017-12-03-single-variable.md" target="_blank">
      
      <i class="fa fa-pencil"></i>Edit this page</a>

    </div> 
  

  <span class="post-date">03 Dec 2017

  <div class="post-categories">
  
  
  <a href="/books/tensorflow/book">Read the TensorFlow book</a>
  
  
</div>

</span>

  <h1 id="single-variable-regression">Single Variable Regression</h1>

<p>Since this is the very first tutorial in this book and no knowledge is assumed about machine learning or TensorFlow, this tutorial is a bit on the long side. This tutorial will give you an overview of how to do machine learning work in general, a mathematical understanding of single variable linear regression, and how to implement it in TensorFlow. If you already feel comfortable with the mathematical concept of linear regression, feel free to skip to the TensorFlow <a href="#implementation">implementation</a>.</p>

<h2 id="motivation">Motivation</h2>

<p>Single variable linear regression is one of the fundamental tools for any interpretation of data. Using linear regression, we can predict continuous variable outcomes given some data, if the data has a roughly linear shape, i.e. it generally has the shape a line. For example, consider the plot below of 2015 US homicide deaths per age<sup id="fnref:fn1"><a href="#fn:fn1" class="footnote">1</a></sup>, and the line of best fit next to it.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Original data</th>
      <th style="text-align: center">Result of single variable linear regression</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="/books/tensorflow/book/ch2-linreg/assets/homicide.png" alt="Homicide Plot" /></td>
      <td style="text-align: center"><img src="/books/tensorflow/book/ch2-linreg/assets/homicide_fit.png" alt="Homicide Regression Plot" /></td>
    </tr>
  </tbody>
</table>

<p>Visually, it appears that this data is approximated pretty well by a “line of best fit”. This is certainly not the only way to approximate this data, but for now it’s pretty good. Single variable linear regression is the tool to find this line of best fit. The line of best fit can then be used to guess how many homicide deaths there would be for ages we don’t have data on. By the end of this tutorial you can run linear regression on this homicide data, and in fact solve any single variable regression problem.</p>

<h2 id="theory">Theory</h2>

<p>Since we don’t have any theory yet to understand linear regression, first we need to develop the theory necessary to program it.</p>

<h3 id="data-set-format">Data set format</h3>

<p>For regression problems, the goal is to predict a continuous variable output, given some input variables (usually also continuous). For single variable regression, we only have one input variable, called \(x\), and our <em>desired</em> output \(y\). Our data set \(D\) then consists of many examples of \(x\) and \(y\), so:
\[
    D = \{ (x_1, y_1), (x_2, y_2), \cdots, (x_m, y_m) \}
\]
where \(m\) is the number of examples in the data set. For a concrete example, the homicide data set plotted above looks like:
\[
    D = \{ (21, 652), (22, 633), \cdots, (50, 197) \}
\]
We will write code to load data sets from files later.</p>

<h3 id="model-concept">Model concept</h3>

<p>So, how can we mathematically model single linear regression? Since the goal is to find the perfect line, let’s start by defining the <strong>model</strong> (the mathematical description of how predictions will be created) as a line:
\[
    y’(x, a, b) = ax + b
\]
where \(x\) is an input, \(a, b\) are constants, and \(y’\) is the prediction for the input \(x\). Note that although this is an equation for a line with \(x\) as the variable, the values of \(a\) and \(b\) determine what specific line it is. To find the best line, we just need to find the best values for \(a\) (the slope) and \(b\) (the y-intercept). For example, the line of best fit for the homicide data above has a slope of about \(a \approx -17.69\) and a y-intercept of \(b \approx 1000\). How we find the magic best values for \(a\) and \(b\) we don’t know yet, but once we find them, prediction is easy, since we just use the formula above.</p>

<p>So, how do we find the correct values of \(a\) and \(b\)? First, we need a way to define what the “best line” is exactly. To do so, we define a <strong>loss function</strong> (also called a cost function), which measures how bad a particular choice of \(a\) and \(b\) are. Values of \(a\) and \(b\) that seem poor (a line that does not fit the data set) should result in a large value of the loss function, whereas good values of \(a\) and \(b\) (a line that fits the data set well) should result in small values of the loss function. In other words, the loss function should measure how far the predicted line is from each of the data points, and add this value up for all data points. We can write this as:
\[
    L(a, b) = \sum_{i=1}^m (y’(x_i, a, b) - y_i)^2
\]
Recall that there are \(m\) examples in the data set, \(x_i\) is the i’th input, and \(y_i\) is the i’th desired output. So, \((y’(x_i, a, b) - y_i)^2\) measures how far the i’th prediction is from the i’th desired output. For example, if the prediction \(y’\) is 7, and the correct output \(y\) is 10, then we would get \((7 - 10)^2 = 9.\) Squaring it is important so that it is always positive.  Finally, we just add up all of these individual losses. Since the smallest possible values for the squared terms indicate that the line fits the data as closely as possible, the line of best fit (determined by the choice of \(a\) and \(b\)) occurs exactly at the smallest value of \(L(a, b)\). For this reason, the model is also called <a href="https://en.wikipedia.org/wiki/Least_squares">least squares regression</a>.</p>

<blockquote>
  <p>Note: The choice to square \(y’(x_i, a, b) - y_i\) is somewhat arbitrary. Though we need to make it positive, we could achieve this in many ways, such as taking the absolute value. In sense, the choice of models and loss functions is the creative aspect of machine learning, and often a certain loss function is chosen simply because it produces satisfying results. Manipulating the loss function to achieve more satisfying results will be done in a later section.</p>
</blockquote>

<p>Creating loss functions (and this exact loss function) will continue to be used throughout this book, from the most simple to more complex models.</p>

<h3 id="optimizing-the-model">Optimizing the model</h3>

<p>At this point, we have fully defined both our model:
\[
    y’(x, a, b) = ax + b
\]
and our loss function, into which we can substitute the model:
\[
    L(a, b) = \sum_{i=1}^m (y’(x_i, a, b) - y_i)^2 = \sum_{i=1}^m (a x_i + b - y_i)^2
\]
We crafted \(L(a, b)\) so that it is smallest exactly when each predicted \(y’\) is as close as possible to actual data \(y\). When this happens, since the distance between the data points and predicted line is as small as possible, using \(a\) and \(b\) produces the line of best fit. Therefore, our goal is to find the values of \(a\) and \(b\) that minimize the function \(L(a, b)\). But what does \(L\) really look like? Well, it is essentially a 3D parabola which looks like:</p>

<p><img src="/books/tensorflow/book/ch2-linreg/assets/minimum.png" alt="Minimum Plot" /></p>

<p>The red dot marked on the plot of \(L\) shows where the desired minimum is. We need an algorithm to find this minimum. From calculus, we know that at the minimum \(L\) must be entirely flat, that is the derivatives are both \(0\):
\[
    \frac{\partial L}{\partial a} = \sum_{i=1}^m 2(ax_i + b - y_i)x_i = 0 \<br />
    \frac{\partial L}{\partial b} = \sum_{i=1}^m 2(ax_i + b - y_i) = 0 <br />
\]
If you need to review this aspect of calculus, I would recommend <a href="https://www.khanacademy.org/math/differential-calculus/analyzing-func-with-calc-dc">Khan Academy videos</a>. Now, for this problem it is possible to solve for \(a\) and \(b\) using the equations above, like we would in a typical calculus course. But for more advanced machine learning this is impossible, so instead we will learn to use an algorithm called <strong><a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a></strong> to find the minimum. The idea is intuitive: place a ball at an arbitrary location on the surface of \(L\), and it will naturally roll downhill towards the flat valley of \(L\) and thus find the minimum. We know the direction of “downhill” at any location since we know the derivatives of \(L\): the derivatives are the direction of greatest upward slope (this is known as the <a href="https://en.wikipedia.org/wiki/Gradient">gradient</a>), so the opposite (negative) derivatives are the most downhill direction. Therefore, if the ball is currently at location \((a, b)\), we can see where it would go by moving it to location \((a’, b’)\) like so:
\[
    a’ = a - \alpha \frac{\partial L}{\partial a} \<br />
    b’ = b - \alpha \frac{\partial L}{\partial b} \<br />
\]
where \(\alpha\) is a constant called the <strong>learning rate</strong>, which we will talk about more later. If we repeat this process then the ball will continue to roll downhill into the minimum. An animation of this process looks like:</p>

<p><img src="/books/tensorflow/book/ch2-linreg/assets/descent_fast.gif" alt="Gradient Descent Animation" /></p>

<p>When we run the gradient descent algorithm for long enough, then it will find the optimal location for \((a, b)\). Once we have the optimal values of \(a\) and \(b\), then that’s it, we can just use them to predict a rate of homicide deaths given any age, using the model:
\[
    y’(x) = ax + b
\]</p>

<h2 id="implementation">Implementation</h2>

<p>Let’s quickly review what we did when defining the theory of linear regression:</p>

<ol>
  <li>Describe the data set</li>
  <li>Define the model</li>
  <li>Define the loss function</li>
  <li>Run the gradient descent optimization algorithm</li>
  <li>Use the optimal model to make predictions</li>
  <li>Profit!</li>
</ol>

<p>When coding this we will follow the exact same steps. So, create a new file <code class="highlighter-rouge">single_var_reg.py</code> in the text editor or IDE of your choice (or experiment in the Python REPL by typing <code class="highlighter-rouge">python</code> at command line), and download the <a href="/books/tensorflow/book/ch2-linreg/code/homicide.csv">homicide death rate data set</a> into the same directory.</p>

<h3 id="importing-the-data">Importing the data</h3>

<p>First, we need to import all the modules we will need:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<p>We use pandas to easily load the CSV homicide data:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">D</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"homicide.csv"</span><span class="p">)</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">num_homicide_deaths</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</code></pre></div></div>
<p>Note that <code class="highlighter-rouge">x_data</code> and <code class="highlighter-rouge">y_data</code> are <em>not</em> single numbers, but are actually <a href="https://en.wikipedia.org/wiki/Vector_space">vectors</a>. The vectors are 30 numbers long, since there are 30 data points in the CSV file. So, <code class="highlighter-rouge">(x_data[0], y_data[0])</code> would be \((x_1, y_1) = (21, 652)\). When we look at multi variable regression later, we will have to work much more with vectors, matrices and linear algebra, but for now you can think of <code class="highlighter-rouge">x_data</code> and <code class="highlighter-rouge">y_data</code> just as lists of numbers. Also, we have to use <code class="highlighter-rouge">np.matrix(...)</code> to convert the array of numbers <code class="highlighter-rouge">D.age.values</code> to an actual numpy vector (likewise for <code class="highlighter-rouge">D.num_homicide_deaths.values</code>).</p>

<p>Whenever possible, I would recommend plotting data, since this helps you verify that you loaded the data set correctly and gain visual intuition about the shape of the data. This is also pretty easy using matplotlib:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span> <span class="c"># The 'x' means that data points will be marked with an x</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Age'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'US Homicide Deaths in 2015'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Relationship between age and homicide deaths in the US'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p>When we converted the data to vectors using <code class="highlighter-rouge">np.matrix()</code>, numpy created vectors with the shape 1 x 30. That is, <code class="highlighter-rouge">x_data</code> consists of only 1 row of numbers, and 30 columns. This is actually great for us when working with TensorFlow, but matplotlib wants vectors that have the shape 30 x 1 (30 rows and 1 column). Writing <code class="highlighter-rouge">x_data.T</code> calculates the <a href="https://en.wikipedia.org/wiki/Transpose">transpose</a> of <code class="highlighter-rouge">x_data</code>, which flips it from a 1 x 30 vector to a 30 x 1 vector. It’s fine if you don’t understand this now, as we will learn more linear algebra later. Anyways, the plot should look like this:
<img src="/books/tensorflow/book/ch2-linreg/assets/homicide.png" alt="Homicide Plot" /></p>

<p>You need to close the plot for your code to continue executing.</p>

<h3 id="defining-the-model">Defining the model</h3>

<p>We have our data prepared and plotted, so now we need to define our model. Recall that the model equation is:
\[
    y’ = ax + b
\]
Before, we thought of \(x\) and \(y’\) as single numbers. However, we just loaded our data set as vectors (lists of numbers), so it will be much more convenient to define our model using vectors instead of single numbers. If we use the convention that \(x\) and \(y’\) are vectors, then we don’t need to change the equation, just our interpretation of it. Multiplying the vector \(x\) by the single number \(a\) just multiplies every number in \(x\) be \(a\), and likewise for adding \(b\). So, the above equation interpreted using vectors is the same thing as:
\[
    \begin{bmatrix}
           y_{1}’, &amp;
           y_{2}’, &amp;
           \dots, &amp;
           y_{m}’,
    \end{bmatrix} = \begin{bmatrix}
           ax_{1} + b, &amp;
           ax_{2} + b, &amp;
           \dots, &amp;
           ax_{m} + b
         \end{bmatrix}
\]</p>

<p>Fortunately, TensorFlow does the work for us of interpreting the simple equation \(y’ = ax + b\) as the more complicated looking vector equation. We just have to tell TensorFlow which things are vectors (\(x\) and \(y’\)), and which are not vectors (\(a\) and \(b\)). First, we define \(x\):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</code></pre></div></div>
<p>This says that we create a <strong>placeholder</strong> that stores floating-point numbers, and has a <strong>shape</strong> of 1 x None. The shape of 1 x None tells TensorFlow that \(x\) is a vector with 1 row, and some unspecified number of columns. Although we don’t tell TensorFlow the number of columns, this is enough to tell TensorFlow that \(x\) is a vector.</p>

<p>Secondly, note that we create a <code class="highlighter-rouge">tf.placeholder</code>: <code class="highlighter-rouge">x</code> does not have a numerical value right now. Instead, we will later feed the values of <code class="highlighter-rouge">x_data</code> into <code class="highlighter-rouge">x</code>. In short, use a <code class="highlighter-rouge">tf.placeholder</code> whenever there are values you wish to fill in later (usually data).</p>

<p>Now, we define \(a\) and \(b\):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>
<p>Unlike <code class="highlighter-rouge">x</code>, we create <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> to be a <strong>variable</strong>, instead of a placeholder. The main difference between a variable and a placeholder is that TensorFlow will automatically find the best values of variables by using gradient descent (later). In other words, a placeholder changes values whenever we choose to feed it different numeric values. A variable changes values continually and automatically during gradient descent. Use a variable for something that is <strong>trainable</strong>, that is, something whose optimal value will be found by an algorithm such as gradient descent.  Since the goal of linear regression is to find the best values of \(a\) and \(b\), the (only) TensorFlow variables in our model are <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>. The conceptual difference between a TensorFlow placeholder and variable is crucial to using TensorFlow properly.</p>

<p>The parameters <code class="highlighter-rouge">("a", shape=(1))</code> indicate the name of the variable, and that <code class="highlighter-rouge">a</code> is a single number, <em>not</em> a vector. In comparison to <code class="highlighter-rouge">x</code>, note that a shape of <code class="highlighter-rouge">(1, None)</code> indicates a vector, while a shape of <code class="highlighter-rouge">(1)</code> indicates a single number.</p>

<p>With <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">a</code> and  <code class="highlighter-rouge">b</code> defined, we can define \(y’\):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_predicted</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>And that’s it to define the model!</p>

<h3 id="defining-the-loss-function">Defining the loss function</h3>

<p>We have the model defined, so now we need to define the loss function. Recall that the loss function is how the model is evaluated (smaller loss values are better), and it is also the function that we need to minimize in terms of \(a\) and \(b\).  Since the loss function compares the model’s output \(y’\) to the correct output \(y\) from the data set, we need to define \(y\) in TensorFlow. Since \(y\) consists of outside data (and we don’t need to train it), we create it as a <code class="highlighter-rouge">tf.placeholder</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
</code></pre></div></div>
<p>Like <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code> is also a vector, since after all <code class="highlighter-rouge">y</code> must store the correct output for each value stored in <code class="highlighter-rouge">x</code>.</p>

<p>Now, we are ready to setup the loss function. Recall that the loss function is:
\[
    L(a, b) = \sum_{i=1}^m (y’(x_i, a, b) - y_i)^2
\]</p>

<p>However, \(y’\) and \(y\) are now being interpreted as vectors. We can rewrite the loss function as:
\[
    L(a, b) = \mathrm{sum}((y’ - y)^2)
\]
Note that since \(y’\) and \(y\) are vectors, \(y’ - y\) is also a vector that just contains every number stored in \(y’\) minus every corresponding number in \(y’\). Likewise, \((y’ - y)^2\) is also a vector, with every number individually squared.  Then, the \(\mathrm{sum}\) function (which I just made up) adds up every number stored in the vector \((y’ - y)^2\). This is the same as the original loss function, but is a vector interpretation of it instead. We can code this directly:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">((</span><span class="n">y_predicted</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">tf.reduce_sum</code> function is an operation which adds up all the numbers stored in a vector. It is called “reduce” since it reduces a large vector down to a single number (the sum). The word “reduce” here has nothing to do with the fact that we will minimize the loss function.</p>

<p>With just these two lines of code we have defined our loss function.</p>

<h3 id="minimizing-the-loss-function-with-gradient-descent">Minimizing the loss function with gradient descent</h3>

<p>With our model and loss function defined, we are now ready to use the gradient descent algorithm to minimize the loss function, and thus find the optimal \(a\) and \(b\). Fortunately, TensorFlow as already implemented the gradient descent algorithm for us, we just need to use it. The algorithm acts almost like a ball rolling downhill into the minimum of the function, but it does so in discrete time steps. TensorFlow does not handle this aspect, we need to be responsible for performing each time step of gradient descent. So, roughly in pseudo-code we want to do this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c"># Tell TensorFlow to do 1 time step of gradient descent</span>
</code></pre></div></div>
<p>We can’t do this yet, since we don’t yet have a way to tell TensorFlow to perform 1 time step of gradient descent. To do so, we create an optimizer with a learning rate (\(\alpha)\) of \(0.2\):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">tf.train.AdamOptimizer</code> knows how to perform the gradient descent algorithm for us (actually a faster version of gradient descent). Note that this <em>does not yet minimize \(L\)</em>. This code only create an optimizer object which we will use later to minimize \(L\). For an explanation of the <code class="highlighter-rouge">learning_rate=0.2</code> parameter (and the <code class="highlighter-rouge">10000</code> loop iterations), see the end of this tutorial.</p>

<p>The second problem we have is we don’t know how to make TensorFlow run actual computations. Everything so far has been only <em>defining</em> things for TensorFlow, not computing things with concrete numbers. To do so, we also need to create a <strong>session</strong>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">session</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
</code></pre></div></div>
<p>A TensorFlow session is how we always have to perform actual computations with TensorFlow. We actually need to perform a computation right now, before doing gradient descent. Previously, we defined the variables <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>, but they don’t have any numeric value right now. They need to have some initial value so gradient descent can work. To solve this, we have TensorFlow initialize <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> with random values:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">global_variables_initializer</span><span class="p">())</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">session.run</code> function is how we always have to run computations with TensorFlow: the parameter is what computation we want to perform.</p>

<p>Finally, we are ready to run the optimization loop pseudo-code that we originally wanted. Using <code class="highlighter-rouge">session.run</code> it looks like:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">current_loss</span><span class="p">,</span> <span class="n">current_a</span><span class="p">,</span> <span class="n">current_b</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">x_data</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">y_data</span>
    <span class="p">})</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"t = </span><span class="si">%</span><span class="s">g, loss = </span><span class="si">%</span><span class="s">g, a = </span><span class="si">%</span><span class="s">g, b = </span><span class="si">%</span><span class="s">g"</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">current_loss</span><span class="p">,</span> <span class="n">current_a</span><span class="p">,</span> <span class="n">current_b</span><span class="p">))</span>
</code></pre></div></div>
<p>Let’s break this down. We use <code class="highlighter-rouge">session.run</code>, but we pass it an array of computations that we want to perform. Specifically, we want to perform 4 computations:</p>
<ol>
  <li><code class="highlighter-rouge">optimizer</code>: performs 1 time step of gradient descent, and updates <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code></li>
  <li><code class="highlighter-rouge">L</code>: returns the current value of the loss function</li>
  <li><code class="highlighter-rouge">a</code>: returns the current value of <code class="highlighter-rouge">a</code></li>
  <li><code class="highlighter-rouge">b</code>: likewise returns the current value of <code class="highlighter-rouge">b</code>.</li>
</ol>

<p>Of these computations, only the <code class="highlighter-rouge">optimizer</code> does not return a value. So, <code class="highlighter-rouge">session.run</code> will return 3 values for us, which we store into variables using the syntax:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span><span class="p">,</span> <span class="n">current_loss</span><span class="p">,</span> <span class="n">current_a</span><span class="p">,</span> <span class="n">current_b</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div></div>

<p>Ok, but what is all of this <code class="highlighter-rouge">feed_dict</code> stuff? Recall that <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are placeholders, and have no actual numerical value on their own. To perform 1 time step of gradient descent, we need to “feed” our actual data (<code class="highlighter-rouge">x_data</code> and <code class="highlighter-rouge">y_data</code>) into the <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> placeholders. So, we use the <code class="highlighter-rouge">feed_dict</code> parameter of <code class="highlighter-rouge">session.run</code> to feed <code class="highlighter-rouge">x_data</code> into <code class="highlighter-rouge">x</code>, and <code class="highlighter-rouge">y_data</code> into <code class="highlighter-rouge">y</code>, by means of a dictionary.</p>

<p>Finally, the last line of the loop prints out the current values of <code class="highlighter-rouge">t</code>, <code class="highlighter-rouge">L</code>, <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>. We don’t need to print these values out, but it is helpful to observe how the training is progressing.</p>

<p>What we want to see from the print statements is that the gradient descent algorithm <strong>converged</strong>, which means that the algorithm stopped making significant progress because it found the minimum location of the loss function. When the last few print outputs look like:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t = 9992, loss = 39295.8, a = -17.271, b = 997.281
t = 9993, loss = 39295.8, a = -17.271, b = 997.282
t = 9994, loss = 39295.9, a = -17.271, b = 997.282
t = 9995, loss = 39295.9, a = -17.271, b = 997.283
t = 9996, loss = 39295.8, a = -17.2711, b = 997.283
t = 9997, loss = 39295.8, a = -17.2711, b = 997.284
t = 9998, loss = 39295.9, a = -17.2711, b = 997.284
t = 9999, loss = 39295.8, a = -17.2711, b = 997.285
</code></pre></div></div>
<p>then we can tell that we have achieved convergence, and therefore found the best values of \(a\) and \(b\).</p>

<h3 id="using-the-trained-model-to-make-predictions">Using the trained model to make predictions</h3>

<p>At this point we have a fully trained model, and know the best values of \(a\) and \(b\). In fact, the equation of the line of best fit is just:
\[
    y’ = -17.2711x + 997.285
\]</p>

<p>The last remaining thing for this tutorial is to plot the predictions of the model on top of a plot of the data. First, we need to create a bunch of input ages that we will predict the homicide rates for. We could use <code class="highlighter-rouge">x_data</code> as the input ages, but it is more interesting to create a new vector of input ages, since then we can predict homicide rates even for ages that were not in the data set. Outside of the training <code class="highlighter-rouge">for</code> loop, we can use the numpy function <code class="highlighter-rouge">linspace</code> to create a bunch of evenly spaced values between 20 and 55:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># x_test_data has values similar to [20.0, 20.1, 20.2, ..., 54.9, 55.0]</span>
<span class="n">x_test_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">55</span><span class="p">))</span>
</code></pre></div></div>
<p>Then, we can feed <code class="highlighter-rouge">x_test_data</code> into the <code class="highlighter-rouge">x</code> placeholder, and save the outputs of the prediction in <code class="highlighter-rouge">y_test_data</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_test_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">y_predicted</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">x_test_data</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Finally, we can plot the original data and the line together:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_test_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_test_data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Age'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'US Homicide Deaths in 2015'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Age and homicide death linear regression'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p>This yields a plot like:</p>

<p><img src="/books/tensorflow/book/ch2-linreg/assets/homicide_fit.png" alt="Homicide Linear Regression Plot" /></p>

<h1 id="concluding-remarks">Concluding Remarks</h1>

<p>Through following this post you have learned two main concepts. First, you learned the <em>general form of supervised machine learning workflows</em>:</p>
<ol>
  <li>Get your data set</li>
  <li>Define your model (the mechanism for how outputs will be predicted from inputs)</li>
  <li>Define your loss function</li>
  <li>Minimize your loss function (usually with a variant of gradient descent, such as <code class="highlighter-rouge">tf.train.AdamOptimizer</code>)</li>
  <li>Once your loss function is minimized, use your trained model to do cool stuff</li>
</ol>

<p>Second, you learned how to implement linear regression (following the above workflow) using TensorFlow. Let’s briefly discuss the above 5 steps, and where to go to improve on them.</p>

<h2 id="1-the-data-set">1. The Data Set</h2>

<p>This one is pretty simple: we need data sets that contain both input and output data. However, we need a data set that is large enough to properly train our model. With linear regression this is fairly easy: this data set only had 33 data points, and the results were pretty good. With larger and more complex models that we will look at later, this becomes much more of a challenge.</p>

<h2 id="2-defining-the-model">2. Defining the model</h2>

<p>For single variable linear regression we used the model \(y’ = ax + b\). Geometrically, this means that the model can only guess lines. Since the homicide data is roughly in the shape of a line, it worked well for this problem. But there are very few problems that are so simple, so soon we will look at more complex models. One other limitation of the current model is it only accepts one input variable. But if our data set had both age and ethnicity, for example, perhaps we could more accurately predict homicide death rate. We will also discuss soon a more complex model that handles multiple input variables.</p>

<h2 id="3-defining-the-loss-function">3. Defining the loss function</h2>

<p>For single variable regression, the loss function we used, \(L = \sum (y’ - y)^2\), is the standard. However, there are a few considerations: first, this loss functions is suitable for this simple model, but with more advanced models this loss function isn’t good enough. We will see why soon. Second, the optimization algorithm converged pretty slowly, needing about \(10000\) iterations. One cause is that the surface of the loss function is almost flat in a certain direction (you can see this in the 3D plot of it). Though this isn’t inherently a problem with the formula for the loss function, the problem surfaces in the loss function. We will also see how to address this problem soon, and converge muster faster.</p>

<h2 id="4-minimizing-the-loss-functions">4. Minimizing the loss functions</h2>

<p>Recall that we created and used the optimizer like so:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c"># Run one step of optimizer</span>
</code></pre></div></div>
<p>You might be wondering what the magic numbers of <code class="highlighter-rouge">learning_rate=0.2</code> (\( \alpha \)) and <code class="highlighter-rouge">10000</code> are.  Let’s start with the learning rate. In each iteration, gradient descent (and variants of it) take one small step that is determined by the derivative of the loss function. The learning rate is just the relative size of the step. So to take larger steps, we can use a larger learning rate. A larger learning rate can help us to converge more quickly, since we cover more distance in each iteration. But a learning rate too large can cause gradient descent to diverge that is, it won’t reliably find the minimum.</p>

<p>So, once you have chosen a learning rate, then you need to run the optimizer for enough iterations so it actually converges to the minimum. The easiest way to make sure it runs long enough is just to monitor the value of the loss function, as we did in this tutorial.</p>

<p>Lastly, we didn’t use normal gradient descent for optimization in this tutorial. Instead we used <code class="highlighter-rouge">tf.train.AdamOptimizer</code>. With small scale problems like this, there isn’t much of a qualitative difference to intuit. In general the <a href="https://medium.com/@nishantnikhil/adam-optimizer-notes-ddac4fd7218">Adam optimizer</a> is faster, smarter, and more reliable than vanilla gradient descent, but this comes into play a lot more with harder problems.</p>

<h2 id="5-use-the-trained-model">5. Use the trained model</h2>

<p>Technically, using the trained model is the easiest part of machine learning: with the best parameters \(a\) and \(b\), you can simply plug new age values into \(x\) to predict new homicide rates. However, trusting that these predictions are correct is another matter entirely. Later in this book we can look at various statistical techniques that can help determine how much we can trust a trained model, but for now consider some oddities with our trained homicide rate model.</p>

<p>One rather weird thing is that it accepts negative ages: according to the model, 1083 people who are -5 years old die from homicide every year in the US. Now, clearly this makes no sense since people don’t have negative ages. So perhaps we should only let the model be valid for people with positives ages. Ok, so then 980 people who are 1 year old die from homicide every year. While this isn’t impossible, it does seem pretty high compared to the known data of 652 for 21 year olds. It might seem possible (likely even) that fewer homicides occur for 1 year olds than 21 year olds: but we don’t have the data for that, and even if we did, our model could not predict it correctly since it only models straight lines. Without more data, we have no basis to conclude that the number of \(1\) year old homicides is even close to 980.</p>

<p>While this might seem like a simple observation in this case, this problem manifests itself continually in machine learning, causing a variety of ethical problems. For example, in 2016 Microsoft released a chatbot on Twitter and <a href="https://www.theverge.com/2016/3/24/11297050/tay-microsoft-chatbot-racist">it quickly learned to say fairly horrible and racist things</a>. More seriously, machine learning is now being used to predict and guide police in cracking down on crime. While the concept might be well-intentioned, the results are despicable, as shown in <a href="http://theconversation.com/why-big-data-analysis-of-police-activity-is-inherently-biased-72640">an article by The Conversation</a>:</p>

<blockquote>
  <p>Our recent study, by Human Rights Data Analysis Group’s Kristian Lum and William Isaac, found that predictive policing vendor PredPol’s purportedly race-neutral algorithm targeted black neighborhoods at roughly twice the rate of white neighborhoods when trained on historical drug crime data from Oakland, California. 
[…] 
But estimates – created from public health surveys and population models – suggest illicit drug use in Oakland is roughly equal across racial and income groups. If the algorithm were truly race-neutral, it would spread drug-fighting police attention evenly across the city.</p>
</blockquote>

<p>With examples like these, we quickly move from a technical discussion about machine learning to a discussion about ethics. While the study of machine learning is traditionally heavily theoretical, I strongly believe that to effectively and <em>fairly</em> apply machine learning in society, we must spend significant effort evaluating the ethics of machine learning models.</p>

<p>This is an open question, and one that I certainly don’t have an answer to right now. For the short term we can focus on the problem of not trusting a simple linear regression model to properly predict data outside of what it has been trained on, while in the long term keeping in mind that “with great power comes great responsibility.”</p>

<h1 id="exercises">Exercises</h1>

<p>Feel free to complete as many of these as you wish, to get more practice with single variable linear regression. Note that for different problems you might have to adjust the learning rate and / or the number of training iterations.</p>

<ol>
  <li>Learn how to use numpy to generate an artificial data set that is appropriate for single variable linear regression, and then train a model on it. As a hint, for any \(x\) value you could create an artificial \(y\) value like so: \(y = ax + b + \epsilon \), where \(\epsilon\) is a random number that isn’t too big, and \(a\) and \(b\) are fixed constants of your choice. If done correctly, your trained model should learn by itself the numbers you chose for \(a\) and \(b\).</li>
  <li>Run single variable linear regression on a data set of your choice. You can look at <a href="http://donaldpinckney.com/ml.html#regression">my list of regression data sets</a> for ideas, you can search <a href="https://www.kaggle.com/datasets">Kaggle</a>, or you can search online, such as I did for the homicide data set. Many data sets might have multiple input variables, and right now you only know how to do single variable linear regression. We will deal with multiple variables soon, but for now you can always use only 1 of the input variables and ignore the rest.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Experiment with altering the loss function, and observe the effects on the trained model. For example, you could change \((y’ - y)^2\) to \(</td>
          <td>y’ - y</td>
          <td>\) (use <code class="highlighter-rouge">tf.abs(...)</code>), or really anything you can think of.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h1 id="complete-code">Complete Code</h1>

<p>The <a href="https://github.com/donald-pinckney/donald-pinckney.github.io/blob/src/books/tensorflow/src/ch2-linreg/code/single_var_reg.py">complete example code is available on GitHub</a>, as well as directly here:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c"># Load the data, and convert to 1x30 vectors</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"homicide.csv"</span><span class="p">)</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">num_homicide_deaths</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

<span class="c"># Plot the data</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Age'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'US Homicide Deaths in 2015'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Relationship between age and homicide deaths in the US'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>



<span class="c">### Model definition ###</span>

<span class="c"># Define x (input data) placeholder</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

<span class="c"># Define the trainable variables</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c"># Define the prediction model</span>
<span class="n">y_predicted</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span>


<span class="c">### Loss function definition ###</span>

<span class="c"># Define y (correct data) placeholder</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

<span class="c"># Define the loss function</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">((</span><span class="n">y_predicted</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


<span class="c">### Training the model ###</span>

<span class="c"># Define optimizer object</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

<span class="c"># Create a session and initialize variables</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">global_variables_initializer</span><span class="p">())</span>

<span class="c"># Main optimization loop</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">current_loss</span><span class="p">,</span> <span class="n">current_a</span><span class="p">,</span> <span class="n">current_b</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">x_data</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">y_data</span>
    <span class="p">})</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"t = </span><span class="si">%</span><span class="s">g, loss = </span><span class="si">%</span><span class="s">g, a = </span><span class="si">%</span><span class="s">g, b = </span><span class="si">%</span><span class="s">g"</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">current_loss</span><span class="p">,</span> <span class="n">current_a</span><span class="p">,</span> <span class="n">current_b</span><span class="p">))</span>


<span class="c">### Using the trained model to make predictions ###</span>

<span class="c"># x_test_data has values similar to [20.0, 20.1, 20.2, ..., 79.9, 80.0]</span>
<span class="n">x_test_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">55</span><span class="p">))</span>

<span class="c"># Predict the homicide rate for each age in x_test_data</span>
<span class="n">y_test_data</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">y_predicted</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">x_test_data</span>
<span class="p">})</span>

<span class="c"># Plot the original data and the prediction line</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_test_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y_test_data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Age'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'US Homicide Deaths in 2015'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Age and homicide death linear regression'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h1 id="references">References</h1>

<div class="footnotes">
  <ol>
    <li id="fn:fn1">
      <p>Centers for Disease Control and Prevention, National Center for Health Statistics. Underlying Cause of Death 1999-2015 on CDC WONDER Online Database, released December, 2016. Data are from the Multiple Cause of Death Files, 1999-2015, as compiled from data provided by the 57 vital statistics jurisdictions through the Vital Statistics Cooperative Program. Accessed at <a href="http://wonder.cdc.gov/ucd-icd10.html">http://wonder.cdc.gov/ucd-icd10.html</a> on Nov 22, 2017 2:18:46 PM.&nbsp;<a href="#fnref:fn1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>



<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

    </div>

  </body>
</html>
